# 25. Reverse Nodes in k-Group（K 个一组翻转链表）

[25. Reverse Nodes in k-Group](https://leetcode.com/problems/reverse-nodes-in-k-group/)（[K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)）

Given the `head`​ of a linked list, reverse the nodes of the list `k`​ at a time, and return *the modified list*.

​`k`​ is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of `k`​ then left-out nodes, in the end, should remain as it is.

You may not alter the values in the list's nodes, only nodes themselves may be changed.

给你链表的头节点 `head`​ ，每 `k`​  个节点一组进行翻转，请你返回修改后的链表。

​`k`​ 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k`​  的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

**Example 1:**

​![image](assets/image-20240705171938-f0h4nbb.png)​

```java
Input: head = [1,2,3,4,5], k = 2
Output: [2,1,4,3,5]
```

**Example 2:**

​![image](assets/image-20240705171957-zb73l9e.png)​

```java
Input: head = [1,2,3,4,5], k = 3
Output: [3,2,1,4,5]
```

# JavaScript

```javascript
var reverseKGroup = function(head, k) {
    // 统计节点个数
    let n = 0, cur = head;
    while(cur){
        cur = cur.next;
        n++;
    }
    let dummy = new ListNode(0, head);
    let p = dummy, pre = null;
    cur = head;
    while(n >= k){
        for (let i = 0; i < k; i++){
            const nxt = cur.next;
            cur.next = pre;
            pre = cur;
            cur = nxt;
        }
        const nxt = p.next; // nxt = 1, nxt = 3
        p.next.next = cur; // 1->3, 3->5
        p.next = pre; // p->2, p->4
        p = nxt; // p = 1, p = 3
        n -= k;
    }
    return dummy.next;
//         pre cur
//         |  |
//   p->1<-2 3<-4->5
//   p->2->1->3<-4->5
//         pre cur
//         |  |
//   p->3<-4 5
//   p->4->3->5
};
```

# Java

```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        int n = 0;
        for (ListNode cur = head; cur != null; cur = cur.next)
            ++n; // 统计节点个数

        ListNode dummy = new ListNode(0, head), p0 = dummy;
        ListNode pre = null, cur = head;
        for (; n >= k; n -= k) {
            for (int i = 0; i < k; ++i) { // 同 92 题
                ListNode nxt = cur.next;
                cur.next = pre; 
                pre = cur;
                cur = nxt;
            }
            ListNode nxt = p0.next;
            p0.next.next = cur;
            p0.next = pre;
            p0 = nxt;
        }
        return dummy.next;
    }
}
```

# 复杂度分析

* 时间复杂度：O(n)，其中 n 为链表节点个数。
* 空间复杂度：O(1)，仅用到若干额外变量。

‍

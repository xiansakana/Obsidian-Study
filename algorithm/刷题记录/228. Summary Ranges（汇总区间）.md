---
title: 228. Summary Ranges（汇总区间）
date: 2024-05-21T18:03:45Z
lastmod: 2024-07-02T12:51:00Z
---

[Summary Ranges](https://leetcode.com/problems/summary-ranges/)（[汇总区间](https://leetcode.cn/problems/summary-ranges)）

You are given a **sorted unique** integer array `nums`​.

A **range** `[a,b]`​ is the set of all integers from `a`​ to `b`​ (inclusive).

Return *the* ***smallest sorted*** *list of ranges that* ***cover all the numbers in the array exactly***. That is, each element of `nums`​ is covered by exactly one of the ranges, and there is no integer `x`​ such that `x`​ is in one of the ranges but not in `nums`​.

Each range `[a,b]`​ in the list should be output as:

* ​`"a->b"`​ if `a != b`​
* ​`"a"`​ if `a == b`​

给定一个  **无重复元素** 的 **有序** 整数数组 `nums`​ 。

返回 ***恰好覆盖数组中所有数字** 的 **最小有序** 区间范围列表 *。也就是说，`nums`​ 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 `nums`​ 的数字 `x`​ 。

列表中的每个区间范围 `[a,b]`​ 应该按如下格式输出：

* ​`"a->b"`​ ，如果 `a != b`​
* ​`"a"`​ ，如果 `a == b`​

我们从数组的位置 0 出发，向右遍历。每次遇到相邻元素之间的差值大于 1 时，我们就找到了一个区间。遍历完数组之后，就能得到一系列的区间的列表。

在遍历过程中，维护下标 `low `​和` high`​ 分别记录区间的起点和终点，对于任何区间都有 `low ≤ high`​。当得到一个区间时，根据 low 和 high 的值生成区间的字符串表示。

当 `low < high`​ 时，区间的字符串表示为 `low → high`​；

当 `low = high`​ 时，区间的字符串表示为 `low`​。

**Example 1:**

```python
Input: nums = [0,1,2,4,5,7]
Output: ["0->2","4->5","7"]
Explanation: The ranges are:
[0,2] --> "0->2"
[4,5] --> "4->5"
[7,7] --> "7"
```

**Example 2:**

```python
Input: nums = [0,2,3,4,6,8,9]
Output: ["0","2->4","6","8->9"]
Explanation: The ranges are:
[0,0] --> "0"
[2,4] --> "2->4"
[6,6] --> "6"
[8,9] --> "8->9"
```

# JavaScript

```javascript
/**
 * @param {number[]} nums
 * @return {string[]}
 */
var summaryRanges = function(nums) {
    const ret = [];
    let i = 0;
    const n = nums.length;
    while (i < n) {
        const low = i;
        i++;
        while (i < n && nums[i] === nums[i - 1] + 1) {
            i++;
        }
        const high = i - 1;
        const temp = ['' + nums[low]];
        if (low < high) {
            temp.push('->');
            temp.push('' + nums[high]);
        }
        ret.push(temp.join(''));
    }
    return ret;
};
```

> 为什么用数组来存temp而不是字符串？
>
> 在 JavaScript 中，使用数组来构建动态生成的字符串通常被认为是一种效率更高的方法，尤其是当字符串需要通过多次拼接来构建时。这是因为字符串在 JavaScript 中是不可变的，每次对字符串进行拼接操作时，实际上都会创建一个新的字符串，这可能导致较高的内存和时间消耗。相比之下，数组可以动态地添加元素，且不需要每次都创建新的数组实例。

所以这道题用字符串也是可行的。

```javascript
/**
 * @param {number[]} nums
 * @return {string[]}
 */
var summaryRanges = function(nums) {
    const ret = [];
    let i = 0;
    const n = nums.length;
    while (i < n) {
        const low = i;
        i++;
        while (i < n && nums[i] === nums[i - 1] + 1) {
            i++;
        }
        const high = i - 1;
        let temp = '' + nums[low];
        if (low < high) {
            temp += '->' + nums[high];
        }
        ret.push(temp);
    }
    return ret;
};
```

# Java

```java
class Solution {
    public List<String> summaryRanges(int[] nums) {
        List<String> ret = new ArrayList<String>();
        int i = 0;
        int n = nums.length;
        while (i < n) {
            int low = i;
            i++;
            while (i < n && nums[i] == nums[i - 1] + 1) {
                i++;
            }
            int high = i - 1;
            StringBuffer temp = new StringBuffer(Integer.toString(nums[low]));
            if (low < high) {
                temp.append("->");
                temp.append(Integer.toString(nums[high]));
            }
            ret.add(temp.toString());
        }
        return ret;
    }
}
```

# 复杂度分析

* 时间复杂度：O(n)，其中 n 为数组的长度。

* 空间复杂度：O(1)。除了用于输出的空间外，额外使用的空间为常数。

‍

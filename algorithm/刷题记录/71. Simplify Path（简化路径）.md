---
title: 71. Simplify Path（简化路径）
date: 2024-06-15T10:28:06Z
lastmod: 2024-07-02T12:55:08Z
---

[71. Simplify Path](https://leetcode.com/problems/simplify-path/) （[简化路径](https://leetcode.cn/problems/simplify-path/)）

Given an absolute path for a Unix-style file system, which begins with a slash `'/'`​, transform this path into its **simplified canonical path**.

In Unix-style file system context, a single period `'.'`​ signifies the current directory, a double period `".."`​ denotes moving up one directory level, and multiple slashes such as `"//"`​ are interpreted as a single slash. In this problem, treat sequences of periods not covered by the previous rules (like `"..."`​) as valid names for files or directories.

The simplified canonical path should adhere to the following rules:

* It must start with a single slash `'/'`​.
* Directories within the path should be separated by only one slash `'/'`​.
* It should not end with a slash `'/'`​, unless it's the root directory.
* It should exclude any single or double periods used to denote current or parent directories.

Return the new path.

给你一个字符串 `path`​ ，表示指向某一文件或目录的 Unix 风格 **绝对路径 **（以 `'/'`​ 开头），请你将其转化为更加简洁的规范路径。

在 Unix 风格的文件系统中，一个点（`.`​）表示当前目录本身；此外，两个点 （`..`​） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，`'//'`​）都被视为单个斜杠 `'/'`​ 。 对于此问题，任何其他格式的点（例如，`'...'`​）均被视为文件/目录名称。

请注意，返回的 **规范路径** 必须遵循下述格式：

* 始终以斜杠 `'/'`​ 开头。
* 两个目录名之间必须只有一个斜杠 `'/'`​ 。
* 最后一个目录名（如果存在）**不能** 以 `'/'`​ 结尾。
* 此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 `'.'`​ 或 `'..'`​）。

返回简化后得到的 **规范路径** 。

**Example 1:**

```python
Input: path = "/home/"
Output: "/home"
Explanation:
The trailing slash should be removed.
```

**Example 2:**

```python
Input: path = "/home//foo/"
Output: "/home/foo"
Explanation:
Multiple consecutive slashes are replaced by a single one.
```

**Example 3:**

```python
Input: path = "/home/user/Documents/../Pictures"
Output: "/home/user/Pictures"
Explanation:
A double period ".." refers to the directory up a level.
```

**Example 4:**

```python
Input: path = "/../"
Output: "/"
Explanation:
Going one level up from the root directory is not possible.
```

**Example 5:**

```python
Input: path = "/.../a/../b/c/../d/./"
Output: "/.../b/d"
Explanation:
"..." is a valid name for a directory in this problem.
```

# JavaScript

```javascript
/**
 * @param {string} path
 * @return {string}
 */
var simplifyPath = function(path) {
    const dirs = path.split('/');
    const stack = [];
    for (const dir of dirs){
        if(dir === ".."){
            if(stack.length){
                stack.pop();
            }
        }else if(dir.length && dir !== "."){
            stack.push(dir);
        }
    }
    return "/" + stack.join("/");
};
```

# Java

```java
class Solution {
    public String simplifyPath(String path) {
        String[] dirs= path.split("/");
        Deque<String> stack = new ArrayDeque<String>();
        for (String dir: dirs) {
            if ("..".equals(dir)) {
                if (!stack.isEmpty()) {
                    stack.pollLast();
                }
            } else if (dir.length() > 0 && !".".equals(dir)) {
                stack.offerLast(dir);
            }
        }
        StringBuffer ans = new StringBuffer();
        if (stack.isEmpty()) {
            ans.append('/');
        } else {
            while (!stack.isEmpty()) {
                ans.append('/');
                ans.append(stack.pollFirst());
            }
        }
        return ans.toString();
    }
}
```

# 复杂度分析

* 时间复杂度：O(n)，其中 n 是字符串 path 的长度。

* 空间复杂度：O(n)。我们需要 O(n)的空间存储 dirs 中的所有字符串。

‍

# 155. Min Stack（最小栈）

[155. Min Stack](https://leetcode.com/problems/min-stack/)（[最小栈](https://leetcode.cn/problems/min-stack/)）

Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.

Implement the `MinStack`​ class:

* ​`MinStack()`​ initializes the stack object.
* ​`void push(int val)`​ pushes the element `val`​ onto the stack.
* ​`void pop()`​ removes the element on the top of the stack.
* ​`int top()`​ gets the top element of the stack.
* ​`int getMin()`​ retrieves the minimum element in the stack.

You must implement a solution with `O(1)`​ time complexity for each function.

设计一个支持 `push`​ ，`pop`​ ，`top`​ 操作，并能在常数时间内检索到最小元素的栈。

实现 `MinStack`​ 类:

* ​`MinStack()`​ 初始化堆栈对象。
* ​`void push(int val)`​ 将元素val推入堆栈。
* ​`void pop()`​ 删除堆栈顶部的元素。
* ​`int top()`​ 获取堆栈顶部的元素。
* ​`int getMin()`​ 获取堆栈中的最小元素。

**Example 1:**

```python
Input
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

Output
[null,null,null,null,-3,null,0,-2]

Explanation
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin(); // return -3
minStack.pop();
minStack.top();    // return 0
minStack.getMin(); // return -2
```

# JavaScript

```javascript

var MinStack = function() {
    this.stack = [];
    this.min_stack = [Infinity]
};

/** 
 * @param {number} val
 * @return {void}
 */
MinStack.prototype.push = function(val) {
    this.stack.push(val);
    this.min_stack.push(Math.min(this.min_stack[this.min_stack.length - 1], val));
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function() {
    this.stack.pop();
    this.min_stack.pop();
};

/**
 * @return {number}
 */
MinStack.prototype.top = function() {
    return this.stack[this.stack.length - 1];
};

/**
 * @return {number}
 */
MinStack.prototype.getMin = function() {
    return this.min_stack[this.min_stack.length - 1];
};

/** 
 * Your MinStack object will be instantiated and called as such:
 * var obj = new MinStack()
 * obj.push(val)
 * obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.getMin()
 */
```

# Java

```java
class MinStack {
    Deque<Integer> xStack;
    Deque<Integer> minStack;

    public MinStack() {
        xStack = new LinkedList<Integer>();
        minStack = new LinkedList<Integer>();
        minStack.push(Integer.MAX_VALUE);
    }
  
    public void push(int x) {
        xStack.push(x);
        minStack.push(Math.min(minStack.peek(), x));
    }
  
    public void pop() {
        xStack.pop();
        minStack.pop();
    }
  
    public int top() {
        return xStack.peek();
    }
  
    public int getMin() {
        return minStack.peek();
    }
}

```

# 复杂度分析

* 时间复杂度：对于题目中的所有操作，时间复杂度均为 O(1)。因为栈的插入、删除与读取操作都是 O(1)，我们定义的每个操作最多调用栈操作两次。

* 空间复杂度：O(n)，其中 n 为总操作数。最坏情况下，我们会连续插入 n 个元素，此时两个栈占用的空间为 O(n)。

‍

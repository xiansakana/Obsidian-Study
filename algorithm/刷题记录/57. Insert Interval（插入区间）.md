---
title: 57. Insert Interval（插入区间）
date: 2024-05-27T17:52:25Z
lastmod: 2024-08-13T18:13:21Z
---

[57. Insert Interval](https://leetcode.com/problems/insert-interval/)（[插入区间](https://leetcode.cn/problems/insert-interval/)）

You are given an array of non-overlapping intervals `intervals`​ where `intervals[i] = [start_i, end_i]`​ represent the start and the end of the `i`​<sup>​`th`​</sup>​ interval and `intervals`​ is sorted in ascending order by `start_i`​. You are also given an interval `newInterval = [start, end]`​ that represents the start and end of another interval.

Insert `newInterval`​ into `intervals`​ such that `intervals`​ is still sorted in ascending order by `start_i`​ and `intervals`​ still does not have any overlapping intervals (merge overlapping intervals if necessary).

Return `intervals`​*after the insertion*.

**Note** that you don't need to modify `intervals`​ in-place. You can make a new array and return it.

给你一个**无重叠的**  *，* 按照区间起始端点排序的区间列表 `intervals`​，其中 `intervals[i] = [start_i, end_i]`​ 表示第 `i`​ 个区间的开始和结束，并且 `intervals`​ 按照 `start_i`​ 升序排列。同样给定一个区间 `newInterval = [start, end]`​ 表示另一个区间的开始和结束。

在 `intervals`​ 中插入区间 `newInterval`​，使得 `intervals`​ 依然按照 `start_i`​ 升序排列，且区间之间不重叠（如果有必要的话，可以合并区间）。

返回插入之后的 `intervals`​。

**注意** 你不需要原地修改 `intervals`​。你可以创建一个新数组然后返回它。

**Example 1:**

```python
Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
Output: [[1,5],[6,9]]
```

**Example 2:**

```python
Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
Output: [[1,2],[3,10],[12,16]]
Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].
```

# 方法一，直接调用56. Merge Intervals（合并区间）的方法

## JavaScript

```javascript
/**
 * @param {number[][]} intervals
 * @param {number[]} newInterval
 * @return {number[][]}
 */
var insert = function(intervals, newInterval) {
    intervals.push(newInterval)
    intervals.sort((a, b) => a[0] - b[0]);
    const merged = [];
    merged.push(intervals[0]);
    for (let i = 1; i < intervals.length; i++) {
        const last = merged[merged.length - 1];
        if (intervals[i][0] > last[1]) {
            merged.push(intervals[i]);
        } else {
            last[1] = Math.max(last[1], intervals[i][1]);
        }
    }
    return merged;
};
```

## 复杂度分析

* 时间复杂度：O(n)，因为原`intervals`​已经是排序的区间， 所以添加一个`newInterval`​只需要排序一次，而合并所需也为O(n)。因此，添加`newInterval`​后排序并合并的时间复杂度为O(n)。

* 空间复杂度：O(n)，其中 n 为区间的数量。

# 方法二，分类讨论

## JavaScript

```javascript
/**
 * @param {number[][]} intervals
 * @param {number[]} newInterval
 * @return {number[][]}
 */
var insert = function(intervals, newInterval) {
    let left = newInterval[0];
    let right = newInterval[1];
    let placed = false;
    const ansList = [];
    for (let interval of intervals) {
        if (interval[0] > right) {
            if (!placed) {
                ansList.push([left, right]);
                placed = true;
            }
            ansList.push(interval);
        } else if (interval[1] < left) {
            ansList.push(interval);
        } else {
            left = Math.min(left, interval[0]);
            right = Math.max(right, interval[1]);
        }
    }
    if (!placed) {
        ansList.push([left, right]);
    }
    return ansList;
};
```

## Java

```java
class Solution {
    public int[][] insert(int[][] intervals, int[] newInterval) {
        int left = newInterval[0];
        int right = newInterval[1];
        boolean placed = false;
        List<int[]> ansList = new ArrayList<int[]>();
        for (int[] interval : intervals) {
            if (interval[0] > right) {
                // 在插入区间的右侧且无交集
                if (!placed) {
                    ansList.add(new int[]{left, right});
                    placed = true;            
                }
                ansList.add(interval);
            } else if (interval[1] < left) {
                // 在插入区间的左侧且无交集
                ansList.add(interval);
            } else {
                // 与插入区间有交集，计算它们的并集
                left = Math.min(left, interval[0]);
                right = Math.max(right, interval[1]);
            }
        }
        if (!placed) {
            ansList.add(new int[]{left, right});
        }
        int[][] ans = new int[ansList.size()][2];
        for (int i = 0; i < ansList.size(); ++i) {
            ans[i] = ansList.get(i);
        }
        return ans;
    }
}
```

## 复杂度分析

* 时间复杂度：O(n)，其中 n 是数组 `intervals`​ 的长度，即给定的区间个数。

* 空间复杂度：O(1)。除了存储返回答案的空间以外，我们只需要额外的常数空间即可。

‍

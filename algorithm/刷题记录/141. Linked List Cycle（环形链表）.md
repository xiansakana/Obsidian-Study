---
title: 141. Linked List Cycle（环形链表）
date: 2024-06-19T14:58:28Z
lastmod: 2024-08-13T18:08:17Z
---

[141. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/)（[环形链表](https://leetcode.cn/problems/linked-list-cycle/)）

Given `head`​, the head of a linked list, determine if the linked list has a cycle in it.

There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next`​ pointer. Internally, `pos`​ is used to denote the index of the node that tail's `next`​ pointer is connected to. **Note that** **​`pos`​**​ **is not passed as a parameter**.

Return `true`​* if there is a cycle in the linked list*. Otherwise, return `false`​.

给你一个链表的头节点 `head`​ ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next`​ 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos`​ 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：**​**​`pos`​** **不作为参数进行传递**。仅仅是为了标识链表的实际情况。

*如果链表中存在环* ，则返回 `true`​ 。 否则，返回 `false`​ 。

**Example 1:**

​![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)​

```python
Input: head = [3,2,0,-4], pos = 1
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).
```

**Example 2:**

​![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png)​

```python
Input: head = [1,2], pos = 0
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 0th node.
```

**Example 3:**

​![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png)​

```python
Input: head = [1], pos = -1
Output: false
Explanation: There is no cycle in the linked list.
```

# 方法一：快慢指针

## JavaScript

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 */

var hasCycle = function(head) {
    let slow = head, fast = head; // 乌龟和兔子同时从起点出发
    while (fast && fast.next) {
        slow = slow.next; // 乌龟走一步
        fast = fast.next.next; // 兔子走两步
        if (fast === slow) // 兔子追上乌龟（套圈），说明有环
            return true;
    }
    return false; // 访问到了链表末尾，无环
};
```

## Java

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */

class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode slow = head, fast = head; // 乌龟和兔子同时从起点出发
        while (fast != null && fast.next != null) {
            slow = slow.next; // 乌龟走一步
            fast = fast.next.next; // 兔子走两步
            if (fast == slow) // 兔子追上乌龟（套圈），说明有环
                return true;
        }
        return false; // 访问到了链表末尾，无环
    }
}
```

## Python

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        slow = fast = head  # 乌龟和兔子同时从起点出发
        while fast and fast.next:
            slow = slow.next  # 乌龟走一步
            fast = fast.next.next  # 兔子走两步
            if fast is slow:  # 兔子追上乌龟（套圈），说明有环
                return True
        return False  # 访问到了链表末尾，无环
```

## 复杂度分析

* 时间复杂度：O(n)，其中 n 为链表的长度。
* 空间复杂度：O(1)，仅用到若干额外变量。

# 方法二：哈希表

## JavaScript

```javascript
var hasCycle = function(head) {
    let seen = new Set();
    while (head !== null) {
        if (seen.has(head)) {
            return true;
        }
        seen.add(head);
        head = head.next;
    }
    return false;
}
```

## Java

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        Set<ListNode> seen = new HashSet<ListNode>();
        while (head != null) {
            if (!seen.add(head)) {
                return true;
            }
            head = head.next;
        }
        return false;
    }
}
```

## Python

```python
class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        seen = set()
        while head:
            if head in seen:
                return True
            seen.add(head)
            head = head.next
        return False
```

## 复杂度分析

* 时间复杂度：O(N)，其中 N 是链表中的节点数。最坏情况下我们需要遍历每个节点一次。
* 空间复杂度：O(N)，其中 N 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次。

‍

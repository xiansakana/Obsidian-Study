# 100. Same Tree（相同的树）

[100. Same Tree](https://leetcode.com/problems/same-tree/)（[相同的树](https://leetcode.cn/problems/same-tree/)）

Given the roots of two binary trees `p`​ and `q`​, write a function to check if they are the same or not.

Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.

给你两棵二叉树的根节点 `p`​ 和 `q`​ ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

**Example 1:**

​![image](assets/image-20240802154606-awxiqi2.png)​

```java
Input: p = [1,2,3], q = [1,2,3]
Output: true
```

**Example 2:**

​![image](assets/image-20240802154619-and52qt.png)​

```java
Input: p = [1,2], q = [1,null,2]
Output: false
```

**Example 3:**

​![image](assets/image-20240802154629-bn746lb.png)​

```java
Input: p = [1,2,1], q = [1,1,2]
Output: false
```

# Java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null || q == null) {
            return p == q;
        }
        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    }
}
```

# 复杂度分析

* 时间复杂度：O(min(n,m))，其中 n 为 p 的节点个数，m 为 q 的节点个数。
* 空间复杂度：O(min(n,m))。最坏情况下，二叉树退化成一条链，递归需要 O(min(n,m)) 的栈空间。

‍

# 399. Evaluate Division（除法求值）

[399. Evaluate Division](https://leetcode.com/problems/evaluate-division/)（[除法求值](https://leetcode.cn/problems/evaluate-division/)）

You are given an array of variable pairs `equations`​ and an array of real numbers `values`​, where `equations[i] = [A<sub>i</sub>, B<sub>i</sub>]`​ and `values[i]`​ represent the equation `A<sub>i</sub> / B<sub>i</sub> = values[i]`​. Each `A<sub>i</sub>`​ or `B<sub>i</sub>`​ is a string that represents a single variable.

You are also given some `queries`​, where `queries[j] = [C<sub>j</sub>, D<sub>j</sub>]`​ represents the `j<sup>th</sup>`​ query where you must find the answer for `C<sub>j</sub> / D<sub>j</sub> = ?`​.

Return *the answers to all queries*. If a single answer cannot be determined, return `-1.0`​.

**Note:**  The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.

**Note:**  The variables that do not occur in the list of equations are undefined, so the answer cannot be determined for them.

给你一个变量对数组 `equations`​ 和一个实数值数组 `values`​ 作为已知条件，其中 `equations[i] = [A<sub>i</sub>, B<sub>i</sub>]`​ 和 `values[i]`​ 共同表示等式 `A<sub>i</sub> / B<sub>i</sub> = values[i]`​ 。每个 `A<sub>i</sub>`​ 或 `B<sub>i</sub>`​ 是一个表示单个变量的字符串。

另有一些以数组 `queries`​ 表示的问题，其中 `queries[j] = [C<sub>j</sub>, D<sub>j</sub>]`​ 表示第 `j`​ 个问题，请你根据已知条件找出 `C<sub>j</sub> / D<sub>j</sub> = ?`​ 的结果作为答案。

返回 **所有问题的答案** 。如果存在某个无法确定的答案，则用 `-1.0`​ 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 `-1.0`​ 替代这个答案。

**注意：** 输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。

**注意：** 未在等式列表中出现的变量是未定义的，因此无法确定它们的答案。

**Example 1:**

```python
Input: equations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]
Output: [6.00000,0.50000,-1.00000,1.00000,-1.00000]
Explanation: 
Given: a / b = 2.0, b / c = 3.0
queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? 
return: [6.0, 0.5, -1.0, 1.0, -1.0 ]
note: x is undefined => -1.0
```

**Example 2:**

```python
Input: equations = [["a","b"],["b","c"],["bc","cd"]], values = [1.5,2.5,5.0], queries = [["a","c"],["c","b"],["bc","cd"],["cd","bc"]]
Output: [3.75000,0.40000,5.00000,0.20000]
```

**Example 3:**

```python
Input: equations = [["a","b"]], values = [0.5], queries = [["a","b"],["b","a"],["a","c"],["x","y"]]
Output: [0.50000,2.00000,-1.00000,-1.00000]
```

# BFS

## Python

```python
    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:
        # 构造图，equations的第一项除以第二项等于value里的对应值，第二项除以第一项等于其倒数
        graph = {}
        for (x, y), v in zip(equations, values):
            if x in graph:
                graph[x][y] = v
            else:
                graph[x] = {y: v}
            if y in graph:
                graph[y][x] = 1/v
            else:
                graph[y] = {x: 1/v}
    
        # dfs找寻从s到t的路径并返回结果叠乘后的边权重即结果
        def dfs(s, t) -> int:
            if s not in graph:
                return -1
            if t == s:
                return 1
            for node in graph[s].keys():
                if node == t:
                    return graph[s][node]
                elif node not in visited:
                    visited.add(node)  # 添加到已访问避免重复遍历
                    v = dfs(node, t)
                    if v != -1:
                        return graph[s][node]*v
            return -1

        # 逐个计算query的值
        res = []
        for qs, qt in queries:
            visited = set()
            res.append(dfs(qs, qt))
        return res
```

## 复杂度分析

* 时间复杂度：O(ML+Q⋅(L+M))，其中 M 为边的数量，Q 为询问的数量，L 为字符串的平均长度。构建图时，需要处理 M 条边，每条边都涉及到 O(L) 的字符串比较；处理查询时，每次查询首先要进行一次 O(L) 的比较，然后至多遍历 O(M) 条边。
* 空间复杂度：O(NL+M)，其中 N 为点的数量，M 为边的数量，L 为字符串的平均长度。为了将每个字符串映射到整数，需要开辟空间为 O(NL) 的哈希表；随后，需要花费 O(M) 的空间存储每条边的权重；处理查询时，还需要 O(N) 的空间维护访问队列。最终，总的复杂度为 O(NL+M+N)=O(NL+M)。

# 带权并查集

## Python

```python
class UnionFind:
    def __init__(self):
        """
        记录每个节点的父节点
        """
        self.father = {}
  
    def find(self,x):
        """
        查找根节点
        路径压缩
        """
        root = x

        while self.father[root] != None:
            root = self.father[root]

        # 路径压缩
        while x != root:
            original_father = self.father[x]
            self.father[x] = root
            x = original_father
     
        return root
  
    def merge(self,x,y,val):
        """
        合并两个节点
        """
        root_x,root_y = self.find(x),self.find(y)
    
        if root_x != root_y:
            self.father[root_x] = root_y

    def is_connected(self,x,y):
        """
        判断两节点是否相连
        """
        return self.find(x) == self.find(y)
  
    def add(self,x):
        """
        添加新节点
        """
        if x not in self.father:
            self.father[x] = None
```

## 复杂度分析

* 时间复杂度：O(ML+N+MlogN+Q⋅(L+logN))。构建图需要 O(ML) 的时间；初始化并查集需要 O(N) 的初始化时间；构建并查集的单次操作复杂度为 O(logN)，共需 O(MlogN) 的时间；每个查询需要 O(L) 的字符串比较以及 O(logN) 的查询。
* 空间复杂度：O(NL)。哈希表需要 O(NL) 的空间，并查集需要 O(N) 的空间。

‍

---
title: 98. Validate Binary Search Tree（验证二叉搜索树）
date: 2024-08-15T22:38:03Z
lastmod: 2024-08-15T23:52:52Z
---

[98. Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/)（[验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)）

Given the `root`​ of a binary tree, *determine if it is a valid binary search tree (BST)* .

A **valid BST** is defined as follows:

* The left subtree

  of a node contains only nodes with keys **less than** the node's key.
* The right subtree of a node contains only nodes with keys **greater than** the node's key.
* Both the left and right subtrees must also be binary search trees.

给你一个二叉树的根节点 `root`​ ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

* 节点的左子树

  只包含 **小于** 当前节点的数。
* 节点的右子树只包含 **大于** 当前节点的数。
* 所有左子树和右子树自身必须也是二叉搜索树。

**Example 1:**

​![image](assets/image-20240815223852-c3cvnai.png)​

```java
Input: root = [2,1,3]
Output: true
```

**Example 2:**

​![image](assets/image-20240815223900-t50ezqi.png)​

```java
Input: root = [5,1,4,null,null,3,6]
Output: false
Explanation: The root node's value is 5 but its right child's value is 4.
```

# 方法一：前序遍历

## Java

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }

    private boolean isValidBST(TreeNode node, long left, long right) {
        if (node == null) {
            return true;
        }
        long x = node.val;
        return left < x && x < right &&
               isValidBST(node.left, left, x) &&
               isValidBST(node.right, x, right);
    }
}
```

## 复杂度分析

* 时间复杂度：O(n)，其中 n 为二叉搜索树的节点个数。
* 空间复杂度：O(n)。最坏情况下，二叉搜索树退化成一条链（注意题目没有保证它是平衡树），因此递归需要 O(n) 的栈空间。

# 方法二：中序遍历

## Java

```java
class Solution {
    private long pre = Long.MIN_VALUE;

    public boolean isValidBST(TreeNode root) {
        if (root == null) {
            return true;
        }
        if (!isValidBST(root.left) || root.val <= pre) {
            return false;
        }
        pre = root.val;
        return isValidBST(root.right);
    }
}
```

## 复杂度分析

* 时间复杂度：O(n)，其中 n 为二叉搜索树的节点个数。
* 空间复杂度：O(n)。最坏情况下，二叉搜索树退化成一条链（注意题目没有保证它是平衡树），因此递归需要 O(n) 的栈空间。

# 

‍

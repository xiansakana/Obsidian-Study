---
title: 106. Construct Binary Tree from Inorder and Postorder Traversal（从中序与后序遍历序列构造二叉树）
date: 2024-08-05T15:09:32Z
lastmod: 2024-08-05T16:35:00Z
---

[106. Construct Binary Tree from Inorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)（[从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)）

Given two integer arrays `inorder`​ and `postorder`​ where `inorder`​ is the inorder traversal of a binary tree and `postorder`​ is the postorder traversal of the same tree, construct and return *the binary tree*.

给定两个整数数组 `inorder`​ 和 `postorder`​ ，其中 `inorder`​ 是二叉树的中序遍历， `postorder`​ 是同一棵树的后序遍历，请你构造并返回这颗 *二叉树* 。

**Example 1:**

​![image](assets/image-20240802170652-kw7e2w7.png)​

```python
Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
Output: [3,9,20,null,null,15,7]
```

**Example 2:**

```python
Input: inorder = [-1], postorder = [-1]
Output: [-1]
```

# 方法一：数组

## Java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        int n = postorder.length;
        if (n == 0){
            return null;
        }
        int leftSize = indexOf(inorder, postorder[n - 1]);
        int[] leftPost = Arrays.copyOfRange(postorder, 0, leftSize);
        int[] rightPost = Arrays.copyOfRange(postorder, leftSize, n - 1);
        int[] leftIn = Arrays.copyOfRange(inorder, 0, leftSize);
        int[] rightIn = Arrays.copyOfRange(inorder, 1 + leftSize, n);
        TreeNode left = buildTree(leftIn, leftPost);
        TreeNode right = buildTree(rightIn, rightPost);
        return new TreeNode(postorder[n - 1], left, right);
    }

    public int indexOf(int[] array, int value){
        for (int i = 0; ; i++){
            if(array[i] == value){
                return i;
            }
        }
    }
}
```

## Python

```python
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        if not postorder:  # 空节点
            return None
        left_size = inorder.index(postorder[-1])  # 左子树的大小
        left = self.buildTree(inorder[:left_size], postorder[:left_size])
        right = self.buildTree(inorder[left_size + 1:], postorder[left_size: -1])
        return TreeNode(postorder[-1], left, right)
```

## 复杂度分析

* 时间复杂度：O(n<sup>2</sup>)，其中 n 为 postorder 的长度。最坏情况下二叉树是一条链，我们需要递归 O(n) 次，每次都需要 O(n)的时间查找 postorder[n−1] 和复制数组。
* 空间复杂度：O(n<sup>2</sup>)。

# 方法二：Hashmap

## Java

```java
class Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        int n = inorder.length;
        Map<Integer, Integer> index = new HashMap<>(n); // 预分配空间
        for (int i = 0; i < n; i++) {
            index.put(inorder[i], i);
        }
        return dfs(inorder, 0, n, postorder, 0, n, index); // 左闭右开区间
    }

    private TreeNode dfs(int[] inorder, int inL, int inR, int[] postorder, int postL, int postR, Map<Integer, Integer> index) {
        if (postL == postR) { // 空节点
            return null;
        }
        int leftSize = index.get(postorder[postR - 1]) - inL; // 左子树的大小
        TreeNode left = dfs(inorder, inL, inL + leftSize, postorder, postL, postL + leftSize, index);
        TreeNode right = dfs(inorder, inL + leftSize + 1, inR, postorder, postL + leftSize, postR - 1, index);
        return new TreeNode(postorder[postR - 1], left, right);
    }
}
```

## Python

```python
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        index = {x: i for i, x in enumerate(inorder)}

        def dfs(in_l: int, in_r: int, post_l: int, post_r: int) -> Optional[TreeNode]:
            if post_l == post_r:  # 空节点
                return None
            left_size = index[postorder[post_r - 1]] - in_l  # 左子树的大小
            left = dfs(in_l, in_l + left_size, post_l, post_l + left_size)
            right = dfs(in_l + left_size + 1, in_r, post_l + left_size, post_r - 1)
            return TreeNode(postorder[post_r - 1], left, right)

        return dfs(0, len(inorder), 0, len(postorder))  # 左闭右开区间
```

## 复杂度分析

* 时间复杂度：O(n)，其中 n 为 inorder 的长度。递归 O(n) 次，每次只需要 O(1) 的时间。
* 空间复杂度：O(n)。

‍

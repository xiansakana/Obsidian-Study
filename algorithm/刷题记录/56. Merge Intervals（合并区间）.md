# 56. Merge Intervals（合并区间）

[Merge Intervals](https://leetcode.com/problems/merge-intervals/)（[合并区间](https://leetcode.cn/problems/merge-intervals/)）

Given an array of `intervals`​ where `intervals[i] = [start_i, end_i]`​, merge all overlapping intervals, and return *an array of the non-overlapping intervals that cover all the intervals in the input*.

以数组 `intervals`​ 表示若干个区间的集合，其中单个区间为 `intervals[i] = [start_i, end_i]`​ 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。

**Example 1:**

```python
Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].
```

**Example 2:**

```python
Input: intervals = [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.
```

# JavaScript

```javascript
/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */
var merge = function(intervals) {
    intervals.sort((a, b) => a[0] - b[0]);
    const merged = [];
    merged.push(intervals[0]);
    for (let i = 1; i < intervals.length; i++) {
        const last = merged[merged.length - 1];
        if (intervals[i][0] > last[1]) {
            merged.push(intervals[i]);
        } else {
            last[1] = Math.max(last[1], intervals[i][1]);
        }
    }
    return merged;
};
```

# Java

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        int length = intervals.length;
        int [][] merge = new int[length][2];
        Arrays.sort(intervals, (x, y)->{
            return x[0] - y[0];
        });
        merge[0] = intervals[0];
        int index = 0;
        for(int i = 0; i < length; i++){
            if(intervals[i][0] > merge[index][1]){
                merge[++index] = intervals[i];
            }else{
                merge[index][1] = Math.max(intervals[i][1], merge[index][1]);
            }
        }
        return Arrays.copyOf(merge, index + 1);
    }
}
```

# 复杂度分析

* 时间复杂度：O(nlog⁡n)，其中 n 为区间的数量。除去排序的开销，我们只需要一次线性扫描，所以主要的时间开销是排序的 O(nlog⁡n)。

* 空间复杂度：O(n)，其中 n 为区间的数量。这里计算的是存储答案之外，使用的额外空间。

‍
